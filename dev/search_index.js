var documenterSearchIndex = {"docs":
[{"location":"tutorials/demo/","page":"-","title":"-","text":"EditURL = \"demo.jl\"","category":"page"},{"location":"tutorials/demo/","page":"-","title":"-","text":"using ClusterDepth\nusing Random\nusing CairoMakie\n\n\nn_t = 40 # timepoints\nn_sub = 50\nn_perm = 5000\n\nsnr = 0.5 # signal to nois\n\n# add a signal to the middle\nsignal = vcat(zeros(n_t ÷ 4), sin.(range(0, π, length = n_t ÷ 2)), zeros(n_t ÷ 4))\n\n# same signal for all subs\nsignal = repeat(signal, 1, n_sub)\n\n\n# add noise\ndata = randn(MersenneTwister(123), n_t, n_sub) .+ snr .* signal\n\n# by default assumes τ=2.3 (~alpha=0.05), and one-sample ttest\n@time pvals = clusterdepth(data);\n\nf = Figure()\nax = f[1, 1] = Axis(f)\n\n\nlines!(abs.(ClusterDepth.studentt(data)))\nh1 = scatter(f[1, 2], pvals; axis = (; yscale = log10), label = \"troendle\")\n\npvals2 = clusterdepth(data; pval_type = :naive)\nh2 = scatter!(1.2:40.2, pvals2, color = \"red\", label = \"naive\")\n#hlines!(([0.05]))\naxislegend()\nf","category":"page"},{"location":"tutorials/demo/","page":"-","title":"-","text":"","category":"page"},{"location":"tutorials/demo/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"EditURL = \"eeg-multichannel.jl\"","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"using ClusterDepth\nusing Random\nusing CairoMakie\nusing UnfoldSim\nusing Unfold\nusing UnfoldMakie\nusing Statistics","category":"page"},{"location":"tutorials/eeg-multichannel/#How-to-use-the-ClusterDepth-multiple-comparison-correction-on-multichannel-data","page":"EEG Example - Multichannel data","title":"How to use the ClusterDepth multiple comparison correction on multichannel data","text":"","category":"section"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"This tutorial is adapted from the single-channel EEG example, and complements it with the HArtMuT NYhead model (https://github.com/harmening/HArtMuT) to simulate multiple channels.","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"First set up the EEG simulation as before, with one subject and 40 trials:","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"design =\n    SingleSubjectDesign(conditions=Dict(:condition => [\"car\", \"face\"])) |>\n    x -> RepeatDesign(x, 40);\np1 = LinearModelComponent(;\n    basis=p100(; sfreq=250),\n    formula=@formula(0 ~ 1),\n    β=[1.0],\n);\n\nn170 = LinearModelComponent(;\n    basis=UnfoldSim.n170(; sfreq=250),\n    formula=@formula(0 ~ 1 + condition),\n    β=[1.0, 0.5], # condition effect - faces are more negative than cars\n);\np300 = LinearModelComponent(;\n    basis=UnfoldSim.p300(; sfreq=250),\n    formula=@formula(0 ~ 1 + condition),\n    β=[1.0, 0], # no p300 condition effect\n);\nnothing #hide","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"Now choose some source coordinates for each of the p100, n170, p300 that we want to simulate, and use the helper function closest_srcs to get the HArtMuT sources that are closest to these coordinates:","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"src_coords = [\n    [20, -78, -10], #p100\n    [-20, -78, -10], #p100\n    [50, -40, -25], #n170\n    [0, -50, 40], #p300\n    [0, 5, 20], #p300\n];\n\nheadmodel_HArtMuT = headmodel()\nget_closest =\n    coord ->\n        UnfoldSim.closest_src(coord, headmodel_HArtMuT.cortical[\"pos\"]) |>\n        pi -> magnitude(headmodel_HArtMuT; type=\"perpendicular\")[:, pi]\n\np1_l = p1 |> c -> MultichannelComponent(c, get_closest([-20, -78, -10]))\np1_r = p1 |> c -> MultichannelComponent(c, get_closest([20, -78, -10]))\nn170_r = n170 |> c -> MultichannelComponent(c, get_closest([50, -40, -25]))\np300_do = p300 |> c -> MultichannelComponent(c, get_closest([0, -50, -40]))\np300_up = p300 |> c -> MultichannelComponent(c, get_closest([0, 5, 20]))\n\ndata, events = simulate(\n    MersenneTwister(1),\n    design,\n    [p1_l, p1_r, n170_r, p300_do, p300_up],\n    UniformOnset(; offset=0.5 * 250, width=100),\n    RedNoise(noiselevel=1);\n    return_epoched=true,\n);\nnothing #hide","category":"page"},{"location":"tutorials/eeg-multichannel/#Plotting","page":"EEG Example - Multichannel data","title":"Plotting","text":"","category":"section"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"This is what the data looks like, for one channel/trial respectively:","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"f = Figure()\nAxis(f[1, 1], title=\"Single channel, all trials\", xlabel=\"time\", ylabel=\"y\")\nseries!(data[1, :, :]', solid_color=(:black, 0.1))\nlines!(mean(data[1, :, :], dims=2)[:, 1], color=:red)\nhlines!([0], color=:gray)\n\nAxis(f[2, 1], title=\"All channels, average over trials\", xlabel=\"time\", ylabel=\"y\")\nseries!(mean(data, dims=3)[:, :, 1], solid_color=(:black, 0.1))\nhlines!([0], color=:gray)\nf","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"And some topoplots:","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"positions = [\n    Point2f(p[1] + 0.5, p[2] + 0.5) for\n    p in to_positions(headmodel_HArtMuT.electrodes[\"pos\"]')\n]\n\ndf = UnfoldMakie.eeg_array_to_dataframe(\n    mean(data, dims=3)[:, :, 1],\n    string.(1:length(positions)),\n);\nΔbin = 20 # 20 samples / bin\nplot_topoplotseries(\n    df,\n    bin_width=20,\n    positions=positions,\n    visual=(; enlarge=1, label_scatter=false),\n)","category":"page"},{"location":"tutorials/eeg-multichannel/#ClusterDepth","page":"EEG Example - Multichannel data","title":"ClusterDepth","text":"","category":"section"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"Now that the simulation is done, let's try out ClusterDepth and plot our results Note that this is a simple test of \"activity\" vs. 0","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"pvals = clusterdepth(data; τ=1.6, nperm=200);\nfig, ax, hm = heatmap(transpose(pvals), colorscale=log10)\nax.title = \"pvals\";\nax.xlabel = \"time\";\nax.ylabel = \"channel\";\nColorbar(fig[:, end+1], hm);\nfig","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"","category":"page"},{"location":"tutorials/eeg-multichannel/","page":"EEG Example - Multichannel data","title":"EEG Example - Multichannel data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"EditURL = \"type1_troendle.jl\"","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"using ClusterDepth\nusing Random\nusing CairoMakie\nusing UnfoldSim\nusing StatsBase\nusing ProgressMeter\nusing Distributions","category":"page"},{"location":"reference/type1_troendle/#Family-Wise-Error-of-Troendle","page":"Troendle FWER","title":"Family Wise Error of Troendle","text":"","category":"section"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"Here we calculate the Family Wise Error of doing ntests at the same time. That is, we want to check that Troendle indeed returns us a type-1 of 5% for a set of tests.","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"The point being, that if you do 30 tests, the chance that one is significant is not 5% but actually","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"(1 - (1 - 0.05)^30) * 100 ##%","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"Let's setup some simulation parameters","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"reps = 1000\nperms = 1000\nntests = 30;\nnothing #hide","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"we will use the student-t in it's 2-sided variant (abs of it)","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"fun = x -> abs.(ClusterDepth.studentt(x));\nnothing #hide","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"this function simulates data without any effect (H0), then the permutations, and finally calls troendle","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"function run_fun(r, perms, fun, ntests)\n    rng = MersenneTwister(r)\n    data = randn(rng, ntests, 50)\n    perm = Matrix{Float64}(undef, size(data, 1), perms)\n    stat = fun(data)\n    for p = 1:perms\n        ClusterDepth.sign_permute!(rng, data)\n        perm[:, p] = fun(data)\n    end\n    return data, stat, troendle(perm, stat)\nend;\nnothing #hide","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"let's test it once","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"data, stats_t, pvals = run_fun(1, perms, fun, ntests);\nprintln(\"data:\", size(data), \" t-stats:\", size(stats_t), \" pvals:\", size(pvals))","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"run the above function reps=1000` times - we also save the uncorrected t-based pvalue","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"pvals_all = fill(NaN, reps, 2, ntests)\nThreads.@threads for r = 1:reps\n    data, stat, pvals = run_fun(r, perms, fun, ntests)\n    pvals_all[r, 1, :] = pvals\n    pvals_all[r, 2, :] = (1 .- cdf.(TDist(size(data, 2)), abs.(stat))) .* 2 # * 2 becaue of twosided. Troendle takes this into account already\nend;\nnothing #hide","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"Let's check in how many of our simlations we have a significant p-value =<0.05","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"res = any(pvals_all[:, :, :] .<= 0.05, dims=3)[:, :, 1]\nmean(res .> 0, dims=1) |> x -> (:troendle => x[1], :uncorrected => x[2])","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"Nice. Troendle corrects the data and we are below 0.05. The  uncorrected simulations are close to what we calculated above!","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"Finally we end this with a short figure to get a better idea of how this data looks like and a histogram of the p-values","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"f = Figure()\nax = f[1, 1] = Axis(f, title=\"t-values\")\n\n\n\nlines!(ax, abs.(ClusterDepth.studentt(data)))\nheatmap!(Axis(f[1, 2], title=\"heatmap of data\"), data)\nseries!(Axis(f[2, 2], title=\"data: subset of left plot\"), data[:, 1:7]')\nh1 = scatter!(Axis(f[2, 1]; yscale=log10, title=\"troendle pvals\"), pvals, label=\"troendle\")\n\nhlines!([0.05, 0.01])\n\nhist!(Axis(f[3, 1], title=\"troendle corrected\"), pvals_all[:, 1, :][:], bins=0:0.01:1.1)\nhist!(Axis(f[3, 2], title=\"uncorrected\"), pvals_all[:, 2, :][:], bins=0:0.01:1.1)\nf","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"","category":"page"},{"location":"reference/type1_troendle/","page":"Troendle FWER","title":"Troendle FWER","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"EditURL = \"type1.jl\"","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"using ClusterDepth\nusing Random\nusing CairoMakie\nusing UnfoldSim\nusing StatsBase\nusing Distributions\nusing DataFrames","category":"page"},{"location":"reference/type1/#Family-Wise-Error-of-ClusterDepth","page":"Clusterdepth FWER","title":"Family Wise Error of ClusterDepth","text":"","category":"section"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"Here we calculate the Family Wise Error the ClusterDepth Correct That is, we want to check that pvalues we get, indeed return us a type-1 of 5% for all time-points The point being, that if you do tests on 113 timepoints, the chance that one is significant is not 5% but","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"(1 - (1 - 0.05)^113) * 100 ##%","category":"page"},{"location":"reference/type1/#Setup-Simulation","page":"Clusterdepth FWER","title":"Setup Simulation","text":"","category":"section"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"Let's setup a simulation using UnfoldSim.jl. We simulate a simple 1x2 design with 20 subjects","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"n_subjects = 20\ndesign = MultiSubjectDesign(\n    n_subjects=n_subjects,\n    n_items=2,\n    items_between=Dict(:condition => [\"small\", \"large\"]),\n)\nfirst(generate_events(design), 5)","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"Next we define a ground-truth signal + relation to events/design with Wilkinson Formulas. we want no condition effect, therefore β for the condition should be 0. We further add some inter-subject variability with the mixed models. We will use a simulated P300 signal, which at 250Hz has 113 samples.","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"signal = MixedModelComponent(;\n    basis=UnfoldSim.p300(; sfreq=250),\n    formula=@formula(0 ~ 1 + condition + (1 | subject)),\n    β=[1.0, 0.0],\n    σs=Dict(:subject => [1]),\n);\nnothing #hide","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"Let's move the actual simulation into a function, so we can call it many times. Note that we use (RedNoise)[https://unfoldtoolbox.github.io/UnfoldSim.jl/dev/literate/reference/noisetypes/] which has lot's of Autocorrelation between timepoints. nice!","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"function run_fun(r)\n    data, events = simulate(\n        MersenneTwister(r),\n        design,\n        signal,\n        UniformOnset(; offset=5, width=4),\n        RedNoise(noiselevel=1);\n        return_epoched=true,\n    )\n    data = reshape(data, size(data, 1), :)\n    data = data[:, events.condition.==\"small\"] .- data[:, events.condition.==\"large\"]\n\n    return data,\n    clusterdepth(data'; τ=quantile(TDist(n_subjects - 1), 0.95), nperm=1000)\nend;\nnothing #hide","category":"page"},{"location":"reference/type1/#Understanding-the-simulation","page":"Clusterdepth FWER","title":"Understanding the simulation","text":"","category":"section"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"let's have a look at the actual data by running it once, plotting condition wise trials, the ERP and histograms of uncorrected and corrected p-values","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"data, pval = run_fun(5)\nconditionSmall = data[:, 1:2:end]\nconditionLarge = data[:, 2:2:end]\npval_uncorrected =\n    1 .-\n    cdf.(\n        TDist(n_subjects - 1),\n        abs.(ClusterDepth.studentt(conditionSmall .- conditionLarge)),\n    )\nsig = pval_uncorrected .<= 0.025;\nnothing #hide","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"For the uncorrected p-values based on the t-distribution, we get a type1 error over \"time\":","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"mean(sig)","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"this is the type 1 error of 5% we expected.","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"note: Note\nType-I error is not the FWER (family wise error rate). FWER is the property of a set of tests (in this case tests per time-point), we can calculate it by repeating such tests,   and checking for each repetition whether any sample of a repetition is significant (e.g. any(sig) followed by a mean(repetitions_anysig)).","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"f = Figure();\nseries!(Axis(f[1, 1], title=\"condition==small\"), conditionSmall', solid_color=:red)\nseries!(Axis(f[1, 2], title=\"condition==large\"), conditionLarge', solid_color=:blue)\nax = Axis(f[2, 1:2], title=\"ERP (mean over trials)\")\n\nsig = allowmissing(sig)\nsig[sig.==0] .= missing\n@show sum(skipmissing(sig))\nlines!(sig, color=:gray, linewidth=4)\nlines!(ax, mean(conditionSmall, dims=2)[:, 1], color=:red)\nlines!(ax, mean(conditionLarge, dims=2)[:, 1], color=:blue)\n\nhist!(Axis(f[3, 1], title=\"uncorrected pvalues\"), pval_uncorrected, bins=0:0.01:1.1)\nhist!(Axis(f[3, 2], title=\"clusterdepth corrected pvalues\"), pval, bins=0:0.01:1.1)\nf","category":"page"},{"location":"reference/type1/#Run-simulations","page":"Clusterdepth FWER","title":"Run simulations","text":"","category":"section"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"This takes some seconds (depending on your infrastructure)","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"reps = 500\nres = fill(NaN, reps, 2)\nThreads.@threads for r = 1:reps\n    data, pvals = run_fun(r)\n    res[r, 1] = mean(pvals .<= 0.05)\n    res[r, 2] =\n        mean(abs.(ClusterDepth.studentt(data)) .>= quantile(TDist(n_subjects - 1), 0.975))\nend;\nnothing #hide","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"Finally, let's calculate the percentage of simulations where we find a significant effect somewhere","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"mean(res .> 0, dims=1) |> x -> (:clusterdepth => x[1], :uncorrected => x[2])","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"Nice, correction seems to work in principle :) Clusterdepth is not necessarily exactly 5%, but with more repetitions we should get there (e.g. with 5000 repetitions, we got 0.051%).","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"info: Info\nif you look closely, the :uncorrected value (can be around 60%) is not as bad as the 99% promised in the introduction. This is due to the correlation between the tests introduced by the noise. Indeed, a good exercise is to repeat everything, but put RedNoise to WhiteNoise","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"","category":"page"},{"location":"reference/type1/","page":"Clusterdepth FWER","title":"Clusterdepth FWER","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"EditURL = \"eeg.jl\"","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"using ClusterDepth\nusing Random\nusing CairoMakie\nusing UnfoldSim\nusing StatsBase\nusing Distributions\nusing DataFrames\nusing Unfold\nusing UnfoldMakie","category":"page"},{"location":"tutorials/eeg/#How-to-use-the-ClusterDepth-multiple-comparison-correction","page":"An EEG Example","title":"How to use the ClusterDepth multiple comparison correction","text":"","category":"section"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"info: Info\nThis tutorial focuses on single-channel data. For multichannel data, see the tutorial \"Further EEG Example\".","category":"page"},{"location":"tutorials/eeg/#Simulating-test-data","page":"An EEG Example","title":"Simulating test-data","text":"","category":"section"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"Let's setup an EEG simulation using UnfoldSim.jl. We simulate a one factor 1x2 design with 20 subjects, each with 40 trials","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"n_subjects = 20\ndesign = MultiSubjectDesign(\n    n_subjects=n_subjects,\n    n_items=40,\n    items_between=Dict(:condition => [\"car\", \"face\"]),\n)\nfirst(generate_events(design), 3)","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"Next we define a ground-truth signal based on a Linear Mixed Model.","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"We simulate a P100, a N170 and a P300 - but an effect only on the N170","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"p1 = MixedModelComponent(;\n    basis=UnfoldSim.p100(; sfreq=250),\n    formula=@formula(0 ~ 1 + (1 | subject)),\n    β=[1.0],\n    σs=Dict(:subject => [1]),\n);\nn170 = MixedModelComponent(;\n    basis=UnfoldSim.n170(; sfreq=250),\n    formula=@formula(0 ~ 1 + condition + (1 + condition | subject)),\n    β=[1.0, -0.5], # condition effect - faces are more negative than cars\n    σs=Dict(:subject => [1, 0.2]), # random slope yes please!\n);\n\np300 = MixedModelComponent(;\n    basis=UnfoldSim.p300(; sfreq=250),\n    formula=@formula(0 ~ 1 + condition + (1 + condition | subject)),\n    β=[1.0, 0], ## no p300 condition effect\n    σs=Dict(:subject => [1, 1.0]), # but a random slope for condition\n);\n\ndata, events = simulate(\n    MersenneTwister(1),\n    design,\n    [p1, n170, p300],\n    UniformOnset(; offset=500, width=100),\n    RedNoise(noiselevel=1);\n    return_epoched=true,\n)\ntimes = range(0, stop=size(data, 1) / 250, length=size(data, 1));\nnothing #hide","category":"page"},{"location":"tutorials/eeg/#Fit-a-model-to-each-subject","page":"An EEG Example","title":"Fit a model to each subject","text":"","category":"section"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"We now have data, but no multiple comparison problem yet - we have to fit one analysis regression model to each time-point of each subject. Thereby, we perform 113 tests and would (without multiple testing correction) expect 5-6 samples to be significant, even if there is no true effect (but there is one ;)).","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"note: Note\nIn principle, we do not need Unfold here - we could simply calculate (subjectwise) means of the conditions, and their time-resolved difference. Using Unfold.jl here simply generalizes it to more complex design, e.g. with continuous predictors etc.","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"models = map(\n    (d, ev) -> (\n        fit(UnfoldModel, @formula(0 ~ 1 + condition), DataFrame(ev), d, times),\n        ev.subject[1],\n    ),\n    eachslice(data; dims=3),\n    groupby(events, :subject),\n);\nnothing #hide","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"now we can inspect the data easily, and extract the face-effect","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"function add_subject!(df, s)\n    df[!, :subject] .= s\n    return df\nend\nallEffects =\n    map(\n        (x) ->\n            (effects(Dict(:condition => [\"car\", \"face\"]), x[1]), x[2]) |>\n            (x) -> add_subject!(x[1], x[2]),\n        models,\n    ) |> e -> reduce(vcat, e)\n\nplot_erp(allEffects; mapping=(color=:condition, group=:subject))","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"Every line is from one subject, the color indicates our two conditions.","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"It is easier to see potential differences if we would plot the difference:","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"First we extract all coefficients in a nice, tidy DataFrame","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"allCoefs =\n    map(m -> (coeftable(m[1]), m[2]) |>\n             (x) -> add_subject!(x[1], x[2]), models) |>\n    e -> reduce(vcat, e)\nplot_erp(allCoefs; mapping=(group=:subject, col=:coefname))","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"This plot now shows the intercept (in our contrast-case the condition:\"car\" ERP), and the difference curve.","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"Next we unstack the tidy-coef table into a matrix and put it to clusterdepth for clusterpermutation testing","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"faceCoefs = allCoefs |> x -> subset(x, :coefname => x -> x .== \"condition: face\")\nerpMatrix =\n    unstack(faceCoefs, :subject, :time, :estimate) |> x -> Matrix(x[:, 2:end])' |> collect\nsummary(erpMatrix)","category":"page"},{"location":"tutorials/eeg/#Clusterdepth","page":"An EEG Example","title":"Clusterdepth","text":"","category":"section"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"pvals = clusterdepth(erpMatrix; τ=quantile(TDist(n_subjects - 1), 0.95), nperm=5000);\nnothing #hide","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"well - that was fast, less than a second for a cluster permutation test. not bad at all!","category":"page"},{"location":"tutorials/eeg/#Plotting","page":"An EEG Example","title":"Plotting","text":"","category":"section"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"Some plotting, and we add the identified cluster","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"first calculate the ERP","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"faceERP =\n    groupby(faceCoefs, [:time, :coefname]) |>\n    x -> combine(x, :estimate => mean => :estimate, :estimate => (x -> std(x) / sqrt(length(x))) => :stderror);\nnothing #hide","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"put the pvalues into a nicer format","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"pvalDF =\n    ClusterDepth.cluster(pvals .<= 0.05) |>\n    x -> DataFrame(\n        :from => x[1] ./ 250,\n        :to => (x[1] .+ x[2]) ./ 250,\n        :coefname => \"condition: face\",\n    )\nplot_erp(faceERP; stderror=true, significance=pvalDF)\nhlines!([0])\ncurrent_figure()","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"Looks good! We identified the cluster :-)","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"","category":"page"},{"location":"tutorials/eeg/","page":"An EEG Example","title":"An EEG Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ClusterDepth","category":"page"},{"location":"#ClusterDepth","page":"Home","title":"ClusterDepth","text":"","category":"section"},{"location":"#Comparison-to-permuco-R-implementation","page":"Home","title":"Comparison to permuco R implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The implementation to Permuco is similar, but ClusterDepth.jl is more barebone - that is, we dont offer many permutation schemes, focus on the ClusterDepth Algorithm, and don't provide the nice wrappers like clusterLM.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Timing wise, a simple test on 50 subjects, 100 repetitions, 5000 permutations shows the following results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"timepoints ClusterDepth.jl permuco julia-speedup\n40 0.03s 2.9s ~100x\n400 0.14s 22s ~160x\n4000 1.88s 240s ~120x","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ClusterDepth]","category":"page"},{"location":"#ClusterDepth.calc_clusterdepth-Tuple{AbstractMatrix{<:Real}, Any}","page":"Home","title":"ClusterDepth.calc_clusterdepth","text":"calc_clusterdepth(data,τ)\n\nreturns tuple with three entries: 1:maxLength, maximal clustervalue per clusterdepth head, same for tail\n\nWe assume data and τ have already been transformed for one/two sided testing, so that we can do d0.>τ for finding clusters\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.cluster-Tuple{BitVector}","page":"Home","title":"ClusterDepth.cluster","text":"finds neighbouring clusters in the vector and returns start + length vectors\n\nif the first and last cluster start on the first/last sample, we dont know their real depth\n\nInput is assumed to be a thresholded Array with only 0/1\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.clusterdepth-Tuple{AbstractArray, Vararg{Any}}","page":"Home","title":"ClusterDepth.clusterdepth","text":"using Base: Stateful clusterdepth(rng,data::AbstractArray;τ=2.3, statfun=x->abs.(studentt(x)),permfun=signpermute!,nperm=5000,pvaltype=:troendle)\n\ncalculate clusterdepth of given datamatrix. \n\ndata: statfun will be applied on last dimension of data (typically this will be subjects)\n\nOptional\n\nτ: Cluster-forming threshold \nnperm: number of permutations, default 5000\nstat_type: default  the one-sample t-test, custom function can be specified (see statfun! and statfun)\nside_type: default: :abs - what function should be applied after the statfun? could be :abs, :square, :positive to test positive clusters, :negative to test negative clusters. Custom function can be provided, see sidefun`\nperm_type: default :sign for one-sample data (e.g. differences), performs sign flips. custom function can be provided, see  permfun\npval_type: how to calculate pvalues within each cluster, default :troendle, see ?pvals\nstatfun / statfun! a function that either takes one or two arguments and aggregates over last dimension. in the two argument case we expect the first argument to be modified inplace and provide a suitable Vector/Matrix.\nsidefun: default abs. Provide a function to be applied on each element of the output of  statfun. \npermfun function to permute the data, should accept an RNG-object and the data. can be inplace, the data is copied, but the same array is shared between permutations\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.ix_sortUnique-Tuple{Any}","page":"Home","title":"ClusterDepth.ix_sortUnique","text":"in some sense: argsort(argunique(x)), returns the indices to get a sorted unique of x\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.multicol_minimum-Tuple{AbstractMatrix, AbstractVector}","page":"Home","title":"ClusterDepth.multicol_minimum","text":"calculates the minimum in `X` along `dims=2` in the columns specified by àrrayOfIndicearrays` which could be e.g. `[[1,2],[5,6],[3,4,7]]`\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.pvals-Tuple{Any}","page":"Home","title":"ClusterDepth.pvals","text":"pvals(data;kwargs...) = pvals(data[2:end],data[1];kwargs...)\n\npvals(data::AbstractVector,stat::Real;type=:twosided)\n\ncalculates pvalues based on permutation results\n\nif called with stat, first entry is assumed to be the observation \n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.pvals-Tuple{Matrix, Vararg{Any}}","page":"Home","title":"ClusterDepth.pvals","text":"Calculate pvals from cluster-depth permutation matrices\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.sign_permute!-Tuple{Any, AbstractArray}","page":"Home","title":"ClusterDepth.sign_permute!","text":"Permutation via random sign-flip Flips signs along the last dimension\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.studentt_test!-Tuple{Any, AbstractMatrix}","page":"Home","title":"ClusterDepth.studentt_test!","text":"studentt_test!(out,x;type=:abs)\n\nstrongly optimized one-sample t-test function.\n\nImplements: t =  mean(x) / ( sqrt(var(x))) / sqrt(size(x,2)-1)\n\nAccepts 2D or 3D matrices, always aggregates over the last dimension\n\n\n\n\n\n","category":"method"},{"location":"#ClusterDepth.troendle-Tuple{AbstractMatrix, AbstractVector}","page":"Home","title":"ClusterDepth.troendle","text":"function troendle(perm::AbstractMatrix,stat::AbstractVector;type=:twosided)\n\nMultiple Comparison Correction as in Troendle 1995\n\nperm with size  ntests x nperms\n\nstat with size ntests\n\ntype can be :twosided (default), :lesser, :greater\n\nHeavily inspired by the R implementation in permuco from Jaromil Frossard\n\nNote: While permuco is released under BSD, the author Jaromil Frossard gave us an MIT license for the troendle and the clusterdepth R-functions.\n\n\n\n\n\n","category":"method"}]
}
